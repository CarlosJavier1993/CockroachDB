from flask import Flask, render_template, request, redirect, url_for, send_file
import psycopg2
import os
from io import BytesIO
import pandas as pd
import traceback

app = Flask(__name__)

# Configura manualmente las variables de entorno
os.environ['DSN'] = 'postgresql://carlos:ZdnCQhSnWqCMoktX6VfA8g@meadow-manatee-4740.jxf.gcp-us-east1.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full'
#os.environ['SSLROOTCERT'] = r'C:\Users\PC202\AppData\Roaming\postgresql\root.crt'

import os
import psycopg2

# Obtén el DSN desde las variables de entorno configuradas en Vercel
dsn = os.environ.get("DSN")

# Construye la ruta al certificado usando una ruta relativa
# Esto obtiene el directorio donde se encuentra el archivo actual (app.py)

root_directory = os.path.dirname(os.path.realpath(__file__))
sslrootcert = os.path.join(root_directory, "root.crt")

print("DSN:", dsn)
print("SSLROOTCERT:", sslrootcert)

try:
    # Conecta a la base de datos usando el DSN y la ruta relativa al certificado
    connection = psycopg2.connect(
        dsn=dsn,
        sslrootcert=sslrootcert
    )
    cursor = connection.cursor()
    print("Conexión exitosa a la base de datos.")
except psycopg2.Error as e:
    print(f"Error en la conexión a la base de datos: {e}")


dsn = os.getenv('DSN')
sslrootcert = os.getenv('SSLROOTCERT')

print("DSN:", dsn)
print("SSLROOTCERT:", sslrootcert)

# Establecer conexión con la base de datos
try:
    connection = psycopg2.connect(
        dsn=dsn,
        sslrootcert=sslrootcert
    )
    cursor = connection.cursor()
except psycopg2.Error as e:
    print(f"Error en la conexión a la base de datos: {e}")
    exit(1)  # Finaliza la ejecución si no se puede conectar



# Crear tabla 'productos' con IDs secuenciales
try:
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS productos (
        id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        nombre TEXT,
        precio DECIMAL,
        stock INT
    )
    """)
    connection.commit()
    print("Tabla 'productos' creada exitosamente.")
except psycopg2.Error as e:
    print(f"Error al crear la tabla 'productos': {e}")
    
# Crear tabla 'ventas' si no existe
try:
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS ventas (
        id SERIAL PRIMARY KEY,
        producto_id INT,
        cantidad INT,
        total DECIMAL,
        fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (producto_id) REFERENCES productos(id)
    )
    """)
    connection.commit()
    print("Tabla 'ventas' creada exitosamente.")
except psycopg2.Error as e:
    connection.rollback()
    print(f"Error al crear la tabla 'ventas': {e}")


@app.route('/factura', methods=['GET', 'POST'])
def factura():
    if request.method == 'POST':
        try:
            producto_id = int(request.form['producto_id'])
            cantidad = int(request.form['cantidad'])
            # Obtener el producto para validar stock y precio
            cursor.execute("SELECT stock, precio FROM productos WHERE id = %s", (producto_id,))
            producto = cursor.fetchone()
            if producto is None:
                return "Producto no encontrado", 404
            stock, precio = producto
            if stock < cantidad:
                return "Stock insuficiente", 400

            total = precio * cantidad

            # NO ES NECESARIO USAR "BEGIN" explícitamente.
            cursor.execute(
                "INSERT INTO ventas (producto_id, cantidad, total) VALUES (%s, %s, %s)",
                (producto_id, cantidad, total)
            )
            cursor.execute(
                "UPDATE productos SET stock = stock - %s WHERE id = %s",
                (cantidad, producto_id)
            )
            connection.commit()
            print("Factura generada. Producto ID:", producto_id, "Cantidad:", cantidad, "Total:", total)
            return redirect(url_for('index'))
        except psycopg2.Error as e:
            connection.rollback()
            print("Error al procesar la factura:", e)
            return "Error al generar la factura", 500
    else:
        cursor.execute("SELECT * FROM productos")
        productos = cursor.fetchall()
        return render_template('factura.html', productos=productos)

@app.route('/reporte', methods=['GET'])
def reporte():
    try:
        # Consulta que une ventas y productos para crear el reporte
        cursor.execute("""
            SELECT v.id AS "ID Venta", 
                   p.nombre AS "Producto", 
                   p.precio AS "Precio",
                   v.cantidad AS "Cantidad", 
                   v.total AS "Total", 
                   v.fecha AS "Fecha"
            FROM ventas v
            JOIN productos p ON v.producto_id = p.id
            ORDER BY v.fecha DESC
        """)
        ventas = cursor.fetchall()
        print("Ventas obtenidas:", ventas)  # Verifica por consola el resultado

        # Crear un DataFrame con los datos obtenidos
        df = pd.DataFrame(ventas, columns=["ID Venta", "Producto", "Precio", "Cantidad", "Total", "Fecha"])
        print("DataFrame:\n", df.head())  # Muestra las primeras filas

        # Verificar que el DataFrame contenga datos; si está vacío, eso explica el reporte "incorrecto"
        if df.empty:
            print("El DataFrame está vacío. Verifica que la tabla ventas tenga datos.")
            return "No hay datos para generar reporte", 404

        # Convertir las columnas de precios y totales a float para evitar problemas con Decimal
        try:
            df["Precio"] = df["Precio"].apply(lambda x: float(x) if x is not None else None)
            df["Total"] = df["Total"].apply(lambda x: float(x) if x is not None else None)
        except Exception as conversion_error:
            print("Error durante la conversión de tipo:", conversion_error)

        # Escribir el DataFrame a un archivo Excel en memoria
        output = BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            df.to_excel(writer, index=False, sheet_name='Reporte de Ventas')
        output.seek(0)
        
        return send_file(
            output,
            mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            as_attachment=True,
            download_name="ReporteVentas.xlsx"
        )
    except Exception as e:
        traceback.print_exc()  # Imprime la traza completa del error en la consola
        print("Error al generar reporte:", e)
        return "Error al generar reporte", 500

@app.route('/test_excel', methods=['GET'])
def test_excel():
    try:
        # Crear un DataFrame de prueba
        df_test = pd.DataFrame({
            'col1': [1, 2, 3],
            'col2': ['a', 'b', 'c']
        })
        output = BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            df_test.to_excel(writer, index=False, sheet_name='Test')
        output.seek(0)
        return send_file(
    output,
    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    as_attachment=True,
    download_name="Test.xlsx"
)
    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"Error en /test_excel: {e}", 500

@app.route('/')
def index():
    try:
        cursor.execute("SELECT * FROM productos")
        records = cursor.fetchall()
        print("Registros obtenidos:", records)  # Imprimir registros obtenidos para depuración
    except psycopg2.Error as e:
        print(f"Error al ejecutar la consulta: {e}")
        records = []
    return render_template('index.html', records=records)

@app.route('/create', methods=['GET', 'POST'])
def create():
    if request.method == 'POST':
        nombre = request.form['nombre']
        precio = request.form['precio']
        stock = request.form['stock']
        try:
            cursor.execute("INSERT INTO productos (nombre, precio, stock) VALUES (%s, %s, %s)", (nombre, precio, stock))
            connection.commit()
            print("Registro creado:", nombre, precio, stock)  # Imprimir detalles del registro creado para depuración
        except psycopg2.Error as e:
            print(f"Error al insertar el registro: {e}")
        return redirect(url_for('index'))
    return render_template('create.html')

@app.route('/update/<int:id>', methods=['GET', 'POST'])
def update(id):
    if request.method == 'POST':
        nombre = request.form['nombre']
        precio = request.form['precio']
        stock = request.form['stock']
        try:
            cursor.execute("UPDATE productos SET nombre = %s, precio = %s, stock = %s WHERE id = %s", (nombre, precio, stock, id))
            connection.commit()
            print("Registro actualizado:", id, nombre, precio, stock)  # Imprimir detalles del registro actualizado para depuración
        except psycopg2.Error as e:
            print(f"Error al actualizar el registro: {e}")
        return redirect(url_for('index'))
    try:
        cursor.execute("SELECT * FROM productos WHERE id = %s", (id,))
        record = cursor.fetchone()
        print("Registro obtenido para actualización:", record)  # Imprimir detalles del registro obtenido para depuración
    except psycopg2.Error as e:
        print(f"Error al obtener el registro: {e}")
        record = None
    return render_template('update.html', record=record)

@app.route('/delete/<int:id>', methods=['GET', 'POST'])
def delete(id):
    if request.method == 'POST':
        try:
            cursor.execute("DELETE FROM productos WHERE id = %s", (id,))
            connection.commit()
            print("Registro eliminado:", id)  # Imprimir detalles del registro eliminado para depuración
        except psycopg2.Error as e:
            print(f"Error al eliminar el registro: {e}")
        return redirect(url_for('index'))
    try:
        cursor.execute("SELECT * FROM productos WHERE id = %s", (id,))
        record = cursor.fetchone()
        print("Registro obtenido para eliminación:", record)  # Imprimir detalles del registro obtenido para depuración
    except psycopg2.Error as e:
        print(f"Error al obtener el registro: {e}")
        record = None
    return render_template('delete.html', record=record)

if __name__ == '__main__':
    app.run(debug=True)
